package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net"
	"os"
)

const header = `// Code generated by ./cmd/gen; DO NOT EDIT.
package cloudranger

import (
	"net"
)

type rangeEntry struct {
	net *net.IPNet
	info IPInfo
}

var cloudRanges = []rangeEntry{
`

const footer = `}`

// Structs to hold the JSON data published by AWS and GCP:

// AWSIPData represents the structure of the JSON data from AWS.
type AWSIPData struct {
	SyncToken    string      `json:"syncToken"`
	CreateDate   string      `json:"createDate"`
	Prefixes     []AWSPrefix `json:"prefixes"`
	IPv6Prefixes []AWSPrefix `json:"ipv6_prefixes"`
}

// AWSPrefix represents an individual IP prefix entry.
type AWSPrefix struct {
	IPPrefix           string `json:"ip_prefix"`
	IPv6Prefix         string `json:"ipv6_prefix"`
	Region             string `json:"region"`
	Service            string `json:"service"`              // currently ignored
	NetworkBorderGroup string `json:"network_border_group"` // currently ignored
}

// GCPIPData represents the structure of the JSON data from AWS.
type GCPIPData struct {
	SyncToken  string      `json:"syncToken"`
	CreateDate string      `json:"createDate"`
	Prefixes   []GCPPrefix `json:"prefixes"`
}

// GCPPrefix represents an individual IP prefix entry.
type GCPPrefix struct {
	IPPrefix   string `json:"ipv4Prefix"`
	IPv6Prefix string `json:"ipv6Prefix"`
	Scope      string `json:"scope"`   // scope is the region on GCP
	Service    string `json:"service"` // currently ignored, and it's always the same 'Google Cloud Platform' anyway
}

func main() {
	out, err := os.Create("zz_generated.go")
	if err != nil {
		log.Fatal(err)
	}
	defer out.Close() //nolint:errcheck

	_, err = io.WriteString(out, header)
	if err != nil {
		log.Fatal(err)
	}

	// AWS:
	// {&net.IPNet{IP: []byte{3, 2, 34, 0}, Mask: []byte{255, 255, 255, 192}}, IPInfo{cloud: "AWS", region: "af-south-1"}},
	{
		var data AWSIPData

		d, err := os.ReadFile("data/aws-ip-ranges.json")
		if err != nil {
			log.Fatal(err)
		}

		if err := json.Unmarshal(d, &data); err != nil {
			log.Fatal(err)
		}

		for _, prefix := range data.Prefixes {
			_, ipnet, err := net.ParseCIDR(prefix.IPPrefix)
			if err != nil {
				log.Fatal(err)
			}
			fmt.Fprintf(out, "\t// AWS: %s, region: %s\n", prefix.IPPrefix, prefix.Region) //nolint:errcheck
			fmt.Fprintf(out,                                                               //nolint:errcheck
				"\t{&net.IPNet{IP: []byte{%d, %d, %d, %d}, Mask: []byte{%d, %d, %d, %d}}, IPInfo{cloud: \"AWS\", region: \"%s\"}},\n",
				ipnet.IP[0], ipnet.IP[1], ipnet.IP[2], ipnet.IP[3],
				ipnet.Mask[0], ipnet.Mask[1], ipnet.Mask[2], ipnet.Mask[3],
				prefix.Region,
			)
		}

		for _, prefix := range data.IPv6Prefixes {
			_, ipnet, err := net.ParseCIDR(prefix.IPv6Prefix)
			if err != nil {
				log.Fatal(err)
			}
			i := ipnet.IP
			m := ipnet.Mask
			fmt.Fprintf(out, "\t// AWS: %s, region: %s\n", prefix.IPv6Prefix, prefix.Region) //nolint:errcheck
			fmt.Fprintf(out,                                                                 //nolint:errcheck
				"\t{&net.IPNet{IP: []byte{%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d}, Mask: []byte{%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d}}, IPInfo{cloud: \"AWS\", region: \"%s\"}},\n",
				i[0], i[1], i[2], i[3], i[4], i[5], i[6], i[7], i[8], i[9], i[10], i[11], i[12], i[13], i[14], i[15],
				m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15],
				prefix.Region,
			)
		}
	}

	// GCP
	// {&net.IPNet{IP: []byte{38, 0, 25, 0, 66, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, Mask: []byte{255, 255, 255, 255, 255, 240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, IPInfo{cloud: "GCP", region: "us-west8"}},
	{
		var data GCPIPData

		d, err := os.ReadFile("data/gcp-cloud.json")
		if err != nil {
			log.Fatal(err)
		}

		if err := json.Unmarshal(d, &data); err != nil {
			log.Fatal(err)
		}

		for _, prefix := range data.Prefixes {
			if prefix.IPPrefix != "" {
				_, ipnet, err := net.ParseCIDR(prefix.IPPrefix)
				if err != nil {
					log.Fatal(err)
				}
				fmt.Fprintf(out, "\t// GCP: %s, region: %s\n", prefix.IPPrefix, prefix.Scope) //nolint:errcheck
				fmt.Fprintf(out,                                                              //nolint:errcheck
					"\t{&net.IPNet{IP: []byte{%d, %d, %d, %d}, Mask: []byte{%d, %d, %d, %d}}, IPInfo{cloud: \"GCP\", region: \"%s\"}},\n",
					ipnet.IP[0], ipnet.IP[1], ipnet.IP[2], ipnet.IP[3],
					ipnet.Mask[0], ipnet.Mask[1], ipnet.Mask[2], ipnet.Mask[3],
					prefix.Scope,
				)
			}

			if prefix.IPv6Prefix != "" {
				_, ipnet, err := net.ParseCIDR(prefix.IPv6Prefix)
				if err != nil {
					log.Fatal(err)
				}
				i := ipnet.IP
				m := ipnet.Mask
				fmt.Fprintf(out, "\t// GCP: %s, region: %s\n", prefix.IPv6Prefix, prefix.Scope) //nolint:errcheck
				fmt.Fprintf(out,                                                                //nolint:errcheck
					"\t{&net.IPNet{IP: []byte{%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d}, Mask: []byte{%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d}}, IPInfo{cloud: \"GCP\", region: \"%s\"}},\n",
					i[0], i[1], i[2], i[3], i[4], i[5], i[6], i[7], i[8], i[9], i[10], i[11], i[12], i[13], i[14], i[15],
					m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15],
					prefix.Scope,
				)
			}
		}
	}

	_, err = io.WriteString(out, footer)
	if err != nil {
		log.Fatal(err)
	}
}
